<?xml version="1.0" encoding="UTF-8"?>
<files>
    <file name="Endpoint.tsx" layer="view:domain" dir="." skip="false" append="false"><![CDATA[
import axios, { AxiosResponse } from 'axios';
import { FlashContext, Message } from '../plataforma/Plataforma';
//import { FlashContext, Message } from "bcb-platform";
import { Result } from "./Model";

let defaultSuccess = function (data: any) {
  console.debug("success:", data);
};
let defaultError = function (data: any) {
  console.debug("error:", data);
};
let processMessage = function (result: Result) {
  console.debug('processMessage:', result);
  let message: Array<Message> = result.messages.map(it => ({
    type: it.type || 'info',
    title: 'Respuesta del Servidor',
    description: it.description,
    action: it.action,
    causes: it.causes,
    duration: 5000
  }));
  FlashContext.flashMessage(message);
};
        
const server: String = 'http://127.0.0.1:8080/${contextPath}/rest';
        
export const createCaller = function(path: string){
    return axios.post(`\${server}/\${path}/`);
}

export const processCaller = function (caller: Promise<AxiosResponse>, success?: (data: any) => void, error?: (data: any) => void) {
  let callerSuccess = success || defaultSuccess;
  let callerError = error || defaultError;
  caller.then(response => {
    console.debug('Response-Success:', response);
    let result: model.Result = response.data;
    processMessage(result);
    if (result.error === false) {
      callerSuccess(result.value);
    } else {
      callerError(result);
    }
  }).catch(response => {
    console.debug('Response-Error:', response);
    let result: model.Result = {
      error: true,
      messages: [{
        type: 'error',
        message: 'Error al invocar al serivio',
        causes: ['Vea el Log del servidor!', response.code + ': ' +response.data]
      }]
    }
    processMessage(result);
    callerError(result);
  });
};

]]></file>
    <file name="Model.tsx" layer="view:domain" dir="." skip="false" append="false"><![CDATA[
export interface FieldFilter {
    operator: string,
    value?: any
}
export interface FieldMessage {
   type: 'primary' | 'secondary' | 'success' | 'danger' | 'warning' | 'info' | 'light' | 'dark';
   icon?: string;
   message: string;
}
export interface Message {
   type: string,
   description: string,
   action?: string,
   causes: Array<string>
}
export interface Result {
  error: boolean,
  messages: Array<Message>,
  value?: any | Array<any>,
}
export interface FilterAbstract {
   config?: {
      index?: number,
      size?: number,
      column?: string,
      sort?: 'asc' | 'desc' | 'none'
   }
}
]]></file>
    <file name="Validate.tsx" layer="view:domain" dir="." skip="false" append="false"><![CDATA[
import { InputTextValue } from "ui-fast";

export const isRequired = function (name: string, inputValue: InputTextValue): InputTextValue {
  if (!inputValue.value) {
    inputValue.state = 'error';
    inputValue.message = 'Se requiere un valor';
  }
  return inputValue;
}

export const isEmail = function (name: string, inputValue: InputTextValue): InputTextValue {
  if (inputValue.value && !inputValue.value.includes('@')) {
    inputValue.state = 'error';
    inputValue.message = 'Correo invalido';
  }
  return inputValue;
}
]]></file>
    <file name="Convert.tsx" layer="view:domain" dir="." skip="false" append="false"><![CDATA[
export const toString = function (value: any): string {
  return '' + value;
}

export const toDateFormat = function (value: date|number): string {
  return '01/01/9999';
}

export const toMoneyFormat = function (value: number): string {
  return '12.456,56';
}
]]></file>
    <% 
    def entityRef = [:]
    mapper.entity.each { entityRef[it.id] = it }
    entityRef.each {
    id, entity ->
    def pkg    = fn.pkg(groupId, artifactId, module);  
    def data   = fn.deduceName(entity.clazz)
    def filter = fn.deduceName(entity.clazz, 'Filter')
    def message = fn.deduceName(entity.clazz, 'Message')
    def serv   = fn.deduceName(entity.clazz, 'Serv')
    def rest   = fn.deduceName(entity.clazz, 'Rest')
    def viewCtrl = fn.deduceName(entity.clazz, '-ctrl')
    def viewPart = fn.deduceName(entity.clazz, '-part')
    def viewServ = fn.deduceName(entity.clazz, '-serv')
    def attr   = []
    attr.addAll(entity.attributes.id.collect{fn.deduceAttrName(it)})
    attr.addAll(entity.attributes.basic.collect{fn.deduceAttrName(it)})
    attr.addAll(entity.attributes.oneToMany.collect{fn.deduceRefName(it, entityRef)})
    attr.addAll(entity.attributes.oneToOne.collect{fn.deduceRefName(it, entityRef)})
    attr.addAll(entity.attributes.manyToOne.collect{fn.deduceRefName(it, entityRef)})
    %>
    <file name="${data.type}Model.tsx" layer="view:domain" dir="${data.path}" skip="false"><![CDATA[

import { FieldFilter, FieldMessage, FilterAbstract } from "../Model";

export interface ${data.type} {<% attr.each{  %>
   ${it.var}?: ${it.jsType},<% } %>
}

export interface ${filter.type} extends FilterAbstract {<% attr.each{  %>
   ${it.var}?: FieldFilter,<% } %>
}

export interface ${message.type} {<% attr.each{  %>
   ${it.var}?: string | FieldMessage,<% } %>
}
]]></file>
    <file name="${rest.type}.tsx" layer="view:domain" dir="${data.path}" skip="false"><![CDATA[

import { createCaller, processCaller } from "../Endpoint";
import { ${data.type}, ${filter.type} } from "./${data.type}Model";

type fnSuccess = (value: Usuario) => void;
type fnError = (response: any) => void;

export const ${rest.var} = {
  ping(callback?: (response: any) => void) {
    let caller = createCaller("/${data.path}/");
    processCaller(caller, callback, callback);
  },
  filter(payload: ${filter.type}, success?: fnSuccess, error?: fnError) {
    let caller = createCaller("/${data.path}/filtrar", payload);
    processCaller(caller, success, error);
  },
  reload(payload: ${data.type}, success?: fnSuccess, error?: fnError) {
    let caller = createCaller("/${data.path}/recargar", payload);
    processCaller(caller, success, error);
  },
  create(payload: ${data.type}, success?: fnSuccess, error?: fnError) {
    let caller = createCaller("/${data.path}/registrar", payload);
    processCaller(caller, success, error);
  },
  update(payload: ${data.type}, success?: fnSuccess, error?: fnError) {
    let caller = createCaller("/${data.path}/actualizar", payload);
    processCaller(caller, success, error);
  },
  remove(payload: ${data.type}, success?: fnSuccess, error?: fnError) {
    let caller = createCaller("/${data.path}/eliminar", payload);
    processCaller(caller, success, error);
  }
}
]]></file>
    <file name="${data.type}Form.tsx" layer="view:domain" dir="${data.path}/part"><![CDATA[
import React from "react";
import { Grid, InputText, InputTextValue, OutputText, Alert } from "ui-fast";
import { ${data.type}, ${data.type}Message } from "../../Model";
import { isRequired } from "../../Validate";
import { toString } from "../../Convert";

export interface ${data.type}FormProps {
  value?: ${data.type},
  message?: ${data.type}Message,
  onValue: (name: string, e: InputTextValue) => void
}

export const ${data.type}Form: React.SFC<${data.type}FormProps> = (props) => {
  let { value, onValue, message } = props;
  message = message || {};
  return (
    value ?
      <Grid cols="4, 8"><% attr.each{  %>
        <OutputText name="${it.var}"
          value="${it.text}" />
        <InputText name="${it.var}"
          value={value.${it.var}} 
          onChange={onValue}
          message={message.${it.var}}
          onValidate={[isRequired]}
          onFormat={toString}
          onConvert={toString} />
        <% } %>
      </Grid>
      :
      <Alert variant="danger"
        message="Se requiere un objeto instanciado"
        icon="warning" />
  );
}
]]></file>
    <file name="${data.type}View.tsx" layer="view:domain" dir="${data.path}/part"><![CDATA[
import React from "react";
import { Grid, OutputText, Alert } from "ui-fast";
import { ${data.type} } from "../../Model";
import { toString } from "../../Convert";

export interface ${data.type}ViewProps {
  value?: ${data.type}
}

export const ${data.type}View: React.SFC<${data.type}ViewProps> = (props) => {
  let { value } = props;
  return (
    value ?
      <Grid cols="4, 8"><% attr.each{  %>
        <OutputText name="${it.var}"
          value="${it.text}" />
        <OutputText name="${it.var}"
          value={value.${it.var}}
          onFormat={toString}/>
        <% } %>
      </Grid>
      :
      <Alert variant="danger"
        message="Se requiere un objeto instanciado"
        icon="warning" />
  );
}
]]></file>
    <file name="${data.type}Table.tsx" layer="view:domain" dir="${data.path}/part"><![CDATA[
import React from "react";
import { Table, Column, TableConfig } from "ui-fast";
import { ${data.type} } from "../../Model";
import { toString } from "../../Convert";

export interface ${data.type}Table {
  values: ${data.type}[],
  select?: ${data.type} | ${data.type}[],
  onSelect?: (e: ${data.type}) => void,
  config?: TableConfig,
  onConfig?: (e: TableConfig) => void
}

export const ${data.type}Table: React.SFC<${data.type}Table> = (props) => {
  let { values, select, config, onSelect, onConfig } = props;
  return (
    <Table pk="id" values={values} select={select} config={config} onSelect={onSelect} onConfig={onConfig}><% attr.each{  %>
      <Column title="${it.text}"
        attr="${it.var}"
        onFormat={toString}
        align="right" />
      <% } %>
    </Table>
  );
}
]]></file>
    <file name="${data.type}Query.tsx" layer="view:domain" dir="${data.path}/part"><![CDATA[
import React from "react";
import { Grid, FilterText, FilterTextValue } from "ui-fast";
import { ${data.type}Filter } from "../../Model";
import { toString } from "../../Convert";

export interface ${data.type}QueryProps {
  value: ${data.type}Filter,
  onChange: (name: string, value: FilterTextValue) => void
}

export const ${data.type}Query: React.SFC<${data.type}QueryProps> = (props) => {
  let { value, onChange } = props;
  return (
    <Grid cols="4, 8"><% attr.each{  %>
      <FilterText name="${it.var}"
        value={value.${it.var}}
        onChange={onChange}
        label="${it.text}"
        onConvert={toString}
        option="number"/>
      <% } %>
    </Grid>
  );
}
]]></file>
    <file name="${data.type}Manager.tsx" layer="view:domain" dir="${data.path}/page"><![CDATA[
//ejemplo 1
]]></file>
    <file name="${data.type}Inbox.tsx" layer="view:domain" dir="${data.path}/page"><![CDATA[
//ejemplo 1
]]></file>
    <file name="${data.type}Create.tsx" layer="view:domain" dir="${data.path}/page"><![CDATA[
//ejemplo 1
]]></file>
    <file name="${data.type}Update.tsx" layer="view:domain" dir="${data.path}/page"><![CDATA[
//ejemplo 1
]]></file>
    <file name="${data.type}Detail.tsx" layer="view:domain" dir="${data.path}/page"><![CDATA[
//ejemplo 1
]]></file>
    <file name="${data.type}Remove.tsx" layer="view:domain" dir="${data.path}/page"><![CDATA[
//ejemplo 1
]]></file>
    <file name="${data.type}Search.tsx" layer="view:domain" dir="${data.path}/page"><![CDATA[
//ejemplo 1
]]></file>
    <file name="${data.type}Proc01.tsx" layer="view:domain" dir="${data.path}/page"><![CDATA[
//ejemplo 1
]]></file>
    <file name="${data.type}Part.tsx" layer="view:domain" dir="${data.path}"><![CDATA[
export * from "./part/${data.type}Table";
export * from "./part/${data.type}Query";
export * from "./part/${data.type}Form";
export * from "./part/${data.type}View";
]]></file>
    <file name="${data.type}Page.tsx" layer="view:domain" dir="${data.path}"><![CDATA[

import React from "react";
import { Panel, Button } from "ui-fast";
import { Route, Switch } from "react-router-dom";
import { ${data.type}Inbox } from "./page/${data.type}Inbox";
import { ${data.type}Create } from "./page/${data.type}Create";
import { ${data.type}Update } from "./page/${data.type}Update";
import { ${data.type}Detail } from "./page/${data.type}Detail";
import { ${data.type}Remove } from "./page/${data.type}Remove";
import { ${rest.var} } from "./${rest.type}";



export const ${data.type}Manager: React.SFC = () => {


    let pingClick = function (name: string) {
        ${rest.var}.ping();
    }
    return (
        <Panel>
            <header>
                <Button name="apply"
                    onClick={pingClick}
                    icon="bell"
                    variant="primary"
                    mode="link"/>
                Administracion de ${data.type}s
            </header>
            <Switch>
                <Route path="/${data.var}/create" component={${data.type}Create} />
                <Route path="/${data.var}/update/:id${data.type}" component={${data.type}Update} />
                <Route path="/${data.var}/detail/:id${data.type}" component={${data.type}Detail} />
                <Route path="/${data.var}/remove/:id${data.type}" component={${data.type}Remove} />
                <Route path="/${data.var}/inbox/:id${data.type}" component={${data.type}Inbox} />
                <Route path="/${data.var}" component={${data.type}Inbox} />
            </Switch>
        </Panel>
    );
}
export {
    ${data.type}Inbox,
    ${data.type}Create,
    ${data.type}Update,
    ${data.type}Detail,
    ${data.type}Remove
};

]]></file>
    <% } %>
</files>
