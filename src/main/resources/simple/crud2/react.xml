<?xml version="1.0" encoding="UTF-8"?>
<files>
    <file name="Endpoint.tsx" layer="view:domain" dir="." skip="false" append="false"><![CDATA[
import axios, { AxiosResponse } from 'axios';
import * as model from './Model';
import Context, { FlashMessage } from '../spa/Spa';

const urlServer: String = 'http://localhost:8080/postulate-sitio-view-0.1.0/rest';
let defaultSuccess = function (data: any) {
  console.debug('success:', data);
};
let defaultError = function (data: any) {
  console.debug('error:', data);
};
let processMessage = function (result: model.Result) {
  let flashMessage: Array<FlashMessage> = result.messages.map(it => ({
    type: it.type || 'info',
    title: 'Respuesta del Servidor',
    description: it.description,
    action: it.action,
    causes: it.causes,
    duration: 5000
  }));
  Context.flashMessage(flashMessage);
};
let processCaller = function (caller: Promise<AxiosResponse>, success?: (data: any) => void, error?: (data: any) => void) {
  let callerSuccess = success || defaultSuccess;
  let callerError = error || defaultError;
  caller.then(response => {
    console.debug('Response-Success:', response);
    let result: model.Result = response.data;
    processMessage(result);
    if (result.error === false) {
      callerSuccess(result.value);
    } else {
      callerError(result);
    }
  }).catch(response => {
    console.debug('Response-Error:', response);
    let result: model.Result = {
      error: true,
      messages: [{
        type: 'error',
        message: 'Error al invocar al serivio',
        causes: ['Vea el Log del servidor!', response.code + ': ' +response.data]
      }]
    }
    processMessage(result);
    callerError(result);
  });
};

]]></file>
    <file name="Model.tsx" layer="view:domain" dir="." skip="false" append="false"><![CDATA[
export interface FieldFilter {
    operator: string,
    value?: any
}
export interface FieldMessage {
   type: 'primary' | 'secondary' | 'success' | 'danger' | 'warning' | 'info' | 'light' | 'dark';
   icon?: string;
   message: string;
}
export interface Message {
   type: string,
   description: string,
   action?: string,
   causes: Array<string>
}
export interface Result {
  error: boolean,
  messages: Array<Message>,
  value?: any | Array<any>,
}
export interface FilterAbstract {
   config?: {
      index?: number,
      size?: number,
      column?: string,
      sort?: 'asc' | 'desc' | 'none'
   }
}
]]></file>
    <file name="Validator.tsx" layer="view:domain" dir="." skip="false" append="false"><![CDATA[
import { InputTextValue } from 'ui-fast';

export const isRequired = function (name: string, inputValue: InputTextValue): InputTextValue {
  if (!inputValue.value) {
    inputValue.state = 'error';
    inputValue.message = 'Se requiere un valor';
  }
  return inputValue;
}

export const isEmail = function (name: string, inputValue: InputTextValue): InputTextValue {
  if (inputValue.value && !inputValue.value.includes('@')) {
    inputValue.state = 'error';
    inputValue.message = 'Correo invalido';
  }
  return inputValue;
}
]]></file>
    <% 
    def entityRef = [:]
    mapper.entity.each { entityRef[it.id] = it }
    entityRef.each {
    id, entity ->
    def pkg    = fn.pkg(groupId, artifactId, module);  
    def data   = fn.deduceName(entity.clazz)
    def filter = fn.deduceName(entity.clazz, 'Filter')
    def message = fn.deduceName(entity.clazz, 'Message')
    def serv   = fn.deduceName(entity.clazz, 'Serv')
    def rest   = fn.deduceName(entity.clazz, 'Rest')
    def viewCtrl = fn.deduceName(entity.clazz, '-ctrl')
    def viewPart = fn.deduceName(entity.clazz, '-part')
    def viewServ = fn.deduceName(entity.clazz, '-serv')
    def attr   = []
    attr.addAll(entity.attributes.id.collect{fn.deduceAttrName(it)})
    attr.addAll(entity.attributes.basic.collect{fn.deduceAttrName(it)})
    attr.addAll(entity.attributes.oneToMany.collect{fn.deduceRefName(it, entityRef)})
    attr.addAll(entity.attributes.oneToOne.collect{fn.deduceRefName(it, entityRef)})
    attr.addAll(entity.attributes.manyToOne.collect{fn.deduceRefName(it, entityRef)})
    %>
    <file name="Model.tsx" layer="view:domain" dir="." skip="false" append="true" comment="${data.const}"><![CDATA[
export interface ${data.type} {<% attr.each{  %>
   ${it.var}?: ${it.jsType},<% } %>
}

export interface ${filter.type} extends FilterAbstract {<% attr.each{  %>
   ${it.var}?: FieldFilter,<% } %>
}

export interface ${message.type} {<% attr.each{  %>
   ${it.var}?: string | FieldMessage,<% } %>
}
]]></file>
    <file name="Endpoint.tsx" layer="view:domain" dir="." skip="false" append="true" comment="${data.const}"><![CDATA[

export const ${rest.var} = {
  ping(callback?: (response: any) => void) {
    let caller = axios.get(urlServer + '/${data.path}/');
    processCaller(caller, callback, callback);
  },
  filter(data: model.${filter.type}, success?: (values: Array<model.${data.type}>) => void, error?: (response: any) => void) {
    let caller = axios.post(urlServer + '/${data.path}/filtrar', data);
    processCaller(caller, success, error);
  },
  reload(data: model.${data.type}, success?: (value: model.${data.type}) => void, error?: (response: any) => void) {
    let caller = axios.post(urlServer + '/${data.path}/recargar', data);
    processCaller(caller, success, error);
  },
  create(data: model.${data.type}, success?: (value: model.${data.type}) => void, error?: (response: any) => void) {
    let caller = axios.post(urlServer + '/${data.path}/registrar', data);
    processCaller(caller, success, error);
  },
  update(data: model.${data.type}, success?: (value: model.${data.type}) => void, error?: (response: any) => void) {
    let caller = axios.post(urlServer + '/${data.path}/actualizar', data);
    processCaller(caller, success, error);
  },
  remove(data: model.${data.type}, success?: (value: model.${data.type}) => void, error?: (response: any) => void) {
    let caller = axios.post(urlServer + '/${data.path}/eliminar', data);
    processCaller(caller, success, error);
  }
}
]]></file>
    <file name="${data.type}Common.tsx" layer="view:domain" dir="${data.path}"><![CDATA[
import React from 'react';
import { Grid, Table, Column, TableConfig, FilterText, FilterTextValue } from 'ui-fast';
import { InputText, InputTextValue, OutputText, Alert } from 'ui-fast';
import { ${data.type}, ${data.type}Filter, ${data.type}Message } from './Model';
import { isRequired, isEmail } from './Validator';

//============================================================

export interface ${data.type}FormProps {
  value?: ${data.type},
  message?: ${data.type}Message,
  onValue: (name: string, e: InputTextValue) => void
}

export const ${data.type}Form: React.SFC<${data.type}FormProps> = (props) => {
  let { value, onValue, message } = props;
  message = message || {};
  return (
    value ?
      <Grid cols="4, 8">
        <OutputText name="id" value="ID" />
        <InputText name="id" value={value.id} onChange={onValue} message={message.id} />
        <OutputText name="correoElectronico" value="Correo Electronico" />
        <InputText name="correoElectronico" value={value.correoElectronico} onChange={onValue} message={message.correoElectronico} onValidate={[isRequired, isEmail]} />
      </Grid>
      :
      <Alert variant="danger" message="Se requiere un objeto instanciado" icon="warning" />
  );
}

// ====================================================================

export interface ${data.type}ViewProps {
  value?: ${data.type}
}

export const ${data.type}View: React.SFC<${data.type}ViewProps> = (props) => {
  let { value } = props;
  return (
    value ?
      <Grid cols="4, 8">
        <OutputText name="id" value="ID" />
        <OutputText name="id" value={value.id} />
        <OutputText name="correoElectronico" value="Correo Electronico" />
        <OutputText name="correoElectronico" value={value.correoElectronico} />
      </Grid>
      :
      <Alert variant="danger" message="Se requiere un objeto instanciado" icon="warning" />
  );
}

// ====================================================================

export interface ${data.type}Table {
  values: ${data.type}[],
  select?: ${data.type} | ${data.type}[],
  onSelect?: (e: ${data.type}) => void,
  config?: TableConfig,
  onConfig?: (e: TableConfig) => void
}

export const ${data.type}Table: React.SFC<${data.type}Table> = (props) => {
  let { values, select, config, onSelect, onConfig } = props;
  return (
    <Table pk="id" values={values} select={select} config={config} onSelect={onSelect} onConfig={onConfig}>
      <Column title="#" attr="id" align="right" width="5" />
      <Column title="Correo Electronico" attr="correoElectronico" align="left" width="95" />
    </Table>
  );
}

// ====================================================================

export interface ${data.type}QueryProps {
  value: ${data.type}Filter,
  onChange: (name: string, value: FilterTextValue) => void
}

export const ${data.type}Query: React.SFC<${data.type}QueryProps> = (props) => {
  let { value, onChange } = props;
  return (
    <Grid cols="4, 8">
      <FilterText name="id" value={value.id} onChange={onChange} label="#" option="number" />
      <FilterText name="correoElectronico" value={value.correoElectronico} onChange={onChange} label="Correo Electronico" />
    </Grid>
  );
}
]]></file>
    <file name="${data.type}Inbox.tsx" layer="view:domain" dir="${data.path}"><![CDATA[
//ejemplo 1
]]></file>
    <file name="${data.type}Create.tsx" layer="view:domain" dir="${data.path}"><![CDATA[
//ejemplo 1
]]></file>
    <file name="${data.type}Update.tsx" layer="view:domain" dir="${data.path}"><![CDATA[
//ejemplo 1
]]></file>
    <file name="${data.type}Detail.tsx" layer="view:domain" dir="${data.path}"><![CDATA[
//ejemplo 1
]]></file>
    <file name="${data.type}Remove.tsx" layer="view:domain" dir="${data.path}"><![CDATA[
//ejemplo 1
]]></file>
    <file name="${data.type}Search.tsx" layer="view:domain" dir="${data.path}"><![CDATA[
//ejemplo 1
]]></file>
    <file name="${data.type}Proc01.tsx" layer="view:domain" dir="${data.path}"><![CDATA[
//ejemplo 1
]]></file>
    <% } %>
</files>
