<?xml version="1.0" encoding="UTF-8"?>
<files>
    <file name="Endpoint.tsx" layer="view:domain" dir="." skip="false" append="false"><![CDATA[
import axios, { AxiosResponse } from 'axios';
import * as model from './Model';
import Context, { FlashMessage } from '../spa/Spa';

const urlServer: String = 'http://localhost:8080/postulate-sitio-view-0.1.0/rest';
let defaultSuccess = function (data: any) {
  console.debug('success:', data);
};
let defaultError = function (data: any) {
  console.debug('error:', data);
};
let processMessage = function (result: model.Result) {
  let flashMessage: Array<FlashMessage> = result.messages.map(it => ({
    type: it.type || 'info',
    title: 'Respuesta del Servidor',
    description: it.description,
    action: it.action,
    causes: it.causes,
    duration: 5000
  }));
  Context.flashMessage(flashMessage);
};
let processCaller = function (caller: Promise<AxiosResponse>, success?: (data: any) => void, error?: (data: any) => void) {
  let callerSuccess = success || defaultSuccess;
  let callerError = error || defaultError;
  caller.then(response => {
    console.debug('Response-Success:', response);
    let result: model.Result = response.data;
    processMessage(result);
    if (result.error === false) {
      callerSuccess(result.value);
    } else {
      callerError(result);
    }
  }).catch(response => {
    console.debug('Response-Error:', response);
    let result: model.Result = {
      error: true,
      messages: [{
        type: 'error',
        message: 'Error al invocar al serivio',
        causes: ['Vea el Log del servidor!', response.code + ': ' +response.data]
      }]
    }
    processMessage(result);
    callerError(result);
  });
};

]]></file>
    <file name="Model.tsx" layer="view:domain" dir="." skip="false" append="false"><![CDATA[
export interface FilterValue {
    operator: string,
    value?: any
}
export interface Message {
  type: string,
  message: string,
  causes: Array<string>
}
export interface Result {
  error: boolean,
  messages: Array<Message>,
  value?: any | Array<any>,
}
export interface FilterAbstract {
   config?: {
      index?: number,
      size?: number,
      column?: string,
      sort?: 'asc' | 'desc' | 'none'
   }
}
]]></file>
    <% 
    def entityRef = [:]
    mapper.entity.each { entityRef[it.id] = it }
    %>

    <% 
    entityRef.each {
    id, entity ->
    def pkg    = fn.pkg(groupId, artifactId, module);  
    def data   = fn.deduceName(entity.clazz)
    def filter = fn.deduceName(entity.clazz, 'Filter')
    def serv   = fn.deduceName(entity.clazz, 'Serv')
    def rest   = fn.deduceName(entity.clazz, 'Rest')
    def viewCtrl = fn.deduceName(entity.clazz, '-ctrl')
    def viewPart = fn.deduceName(entity.clazz, '-part')
    def viewServ = fn.deduceName(entity.clazz, '-serv')
    def attr   = []
    attr.addAll(entity.attributes.id.collect{fn.deduceAttrName(it)})
    attr.addAll(entity.attributes.basic.collect{fn.deduceAttrName(it)})
    attr.addAll(entity.attributes.oneToMany.collect{fn.deduceRefName(it, entityRef)})
    attr.addAll(entity.attributes.oneToOne.collect{fn.deduceRefName(it, entityRef)})
    attr.addAll(entity.attributes.manyToOne.collect{fn.deduceRefName(it, entityRef)})
    %>
    <file name="Model.tsx" layer="view:domain" dir="." skip="false" append="true" comment="${data.const}"><![CDATA[
export interface ${data.type} {<% attr.each{  %>
   ${it.var}?: ${it.jsType},<% } %>
}

export interface ${filter.type} extends FilterAbstract {<% attr.each{  %>
   ${it.var}?: FilterValue,<% } %>
}
]]></file>
    <file name="Endpoint.tsx" layer="view:domain" dir="." skip="false" append="true" comment="${data.const}"><![CDATA[

export const ${rest.var} = {
  ping(callback?: (response: any) => void) {
    let caller = axios.get(urlServer + '/${data.path}/');
    processCaller(caller, callback, callback);
  },
  filter(data: model.${filter.type}, success?: (values: Array<model.${data.type}>) => void, error?: (response: any) => void) {
    let caller = axios.post(urlServer + '/${data.path}/filtrar', data);
    processCaller(caller, success, error);
  },
  reload(data: model.${data.type}, success?: (value: model.${data.type}) => void, error?: (response: any) => void) {
    let caller = axios.post(urlServer + '/${data.path}/recargar', data);
    processCaller(caller, success, error);
  },
  create(data: model.${data.type}, success?: (value: model.${data.type}) => void, error?: (response: any) => void) {
    let caller = axios.post(urlServer + '/${data.path}/registrar', data);
    processCaller(caller, success, error);
  },
  update(data: model.${data.type}, success?: (value: model.${data.type}) => void, error?: (response: any) => void) {
    let caller = axios.post(urlServer + '/${data.path}/actualizar', data);
    processCaller(caller, success, error);
  },
  remove(data: model.${data.type}, success?: (value: model.${data.type}) => void, error?: (response: any) => void) {
    let caller = axios.post(urlServer + '/${data.path}/eliminar', data);
    processCaller(caller, success, error);
  }
}
]]></file>
    <file name="${data.type}\$Part.tsx" layer="view:domain" dir="${data.path}"><![CDATA[
//ejemplo 1
]]></file>
    <file name="${data.type}\$Page.tsx" layer="view:domain" dir="${data.path}"><![CDATA[
//ejemplo 1
]]></file>
    <% } %>
</files>
